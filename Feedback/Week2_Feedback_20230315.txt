Starting code feedback for Pasith, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 194.62 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: .git, Week7, GIS_week, Week1, Week3, Feedback, HPC, Miniproject, Week2

Found the following files in parent directory: README.md, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
#allow list
.gitkeep
!README.md
!.gitignore
!/code
!/results
!/sandbox
!/data

#ignore list
*.pdf
*.aux
*.bbl
*.log
*.blg
*.tmp
*.rasta

**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# CMEE Coursework Repository

![alt text](https://pxl-imperialacuk.terminalfour.net/fit-in/720x462/prod01/channel_2/media/migration/visit/Fern--t_1448877552018_0--tojpeg_1572444324894_x4.jpg)
\\
*Author: Pasith Prayoonrat*

*Created: Oct 2022*

This is the repository of the work attempted by Pasith Prayoonrat on the "Multilingual Quantitative Biologist" course within the Computational Methods in Ecology and Evolution (CMEE) course taught in the first term. (https://mhasoba.github.io/TheMulQuaBio/intro.html)

## Table of Contents
1. Week 1: UNIX and Linux, shell scripting, git and Latex
2. Week 2: Python
3. Week 3: R
4. Week 7: Python 2
5. Miniproject: Project about model fitting
6. HPC: High Performance Computing Work

**********************************************************************

======================================================================
Looking for the weekly directories...

Found 5 weekly directories: GIS_week, Week1, Week2, Week3, Week7

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: code, sandbox, results, data

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# Week 2

*Author: Pasith Prayoonrat*

*Created: Week 2*

This directory contains the scripts, data, and results from week 2. <br /> This README file will contain detailed information on the files in the code directory.

## Directory Structure:

*codes: This directory contains all the relevant codes in week 2.*<br />
*data: Contains files holding data that could be use in the relevant script.*<br />
*sandbox: This is my playground.*<br />
*results: Contains relevant output of the codes written in week 2.*<br />

### In Code you shall find:
 
 Script       | Description
 ------------- | -------------
 MyExampleScript.py | An example script of how to run a python script. 
 align_seqs.py  | A script for comparing and aligning two DNA sequences from the data folder and produce an output file in the results folder.
 basic_csv.py | Basic csv script to show how to run a csv script in python.
 basic_io1.py| A script showing how to input file in python.
 basic_io2.py | A script showing how to output file in python.
 basic_io3.py | A script showing how to store file in python.
 boilerplate.py | A basic boilerplate template for python. Showing how to create a function and make sure the function is call from the command line.
 cfexercises1.py | Different examples of foo function in a python script.
 cfexercises2.py | Different examples of hello function in a python script.
 control_flow.py | A script containing functions explaining the use of control statements.
 debugme.py | A script saying that it wants you to debug it.
 dictionary.py | A practical python exercise on how to write a dictionary and list comprehension of taxas and species from a given nested tuples.
 lc1.py | A python practical on list comprehensions and loops.
 lc2.py | More python practical on list comprehensions and loops.
 loops.py | A script containing examples of loops.
 oaks.py | A script containing a function which is used to determine whether a species is an oak.
 oaks_debugme.py | A practical problem on debugging of a function that determine whether a species is an oak.
 scope.py | A script containing a function that determine a variable within a scope.
 sysargv.py | A script containing basic sys.argv in python.
 test_control_flow.py | A script showing the use of control statements in function.
 tuple.py | A python practical about how to print tuples into seperate lines.
 using_name.py | A script containing an example of the use of a main module.
 align_seq_fasta.py | A groupwork script on aligning fasta to find the best sequence match
 align_seq_better.py | A groupwork script to find out all the equally best alignment sequence
**********************************************************************

Results directory is empty - good! 

Found 24 code files: scope.py, debugme.py, lc2.py, align_seqs_fasta.py, control_flow.py, loops.py, basic_io3.py, cfexercises1.py, oaks.py, align_seqs_better.py, align_seqs.py, using_name.py, dictionary.py, test_control_flow.py, sysargv.py, tuple.py, cfexercises2.py, basic_io1.py, basic_io2.py, boilerplate.py, MyExampleScript.py, lc1.py, basic_csv.py, oaks_debugme.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file scope.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
A scirpt containing a function that determine a variable within a scope.
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

# example of local variables (= only accessible inside their function)
i = 1
x = 0
for i in range(10):
    x += 1
print(x)
print(i)


# now encapsulating this loop into a function...
i = 1
x = 0
def a_function(y):
    """Add one to variable 'x' 'y' times and return x"""
    x = 0
    for i in range(y):
        x += 1
    return x
x = a_function(10)
print(x)
print(i)
## --> both x and i are localised to the function
## --> x was updated to the main workspace bc it was explicitly returned from the function
## --> i remained unchanged outside the function bc it was not returned


####################################################################################

# GLOBAL VARIABLES

# example:

_a_global = 10 # a global variable

if _a_global >= 5:
    _b_global = _a_global + 5 # also a global variable
    
print("Before calling a_function, outside the function, the value of _a_global is", _a_global)
print("Before calling a_function, outside the function, the value of _b_global is", _b_global)

def a_function():
    """Define a local variable. If it is greater than or equal to four, add five and assign to a new local variable. Also define another local variable."""
    _a_global = 4 # a local variable
    
    if _a_global >= 4:
        _b_global = _a_global + 5 # also a local variable
    
    _a_local = 3
    
    print("Inside the function, the value of _a_global is", _a_global)
    print("Inside the function, the value of _b_global is", _b_global)
    print("Inside the function, the value of _a_local is", _a_local)
    
a_function()

print("After calling a_function, outside the function, the value of _a_global is (still)", _a_global)
print("After calling a_function, outside the function, the value of _b_global is (still)", _b_global)

#print("After calling a_function, outside the function, the value of _a_local is ", _a_local)
# this line returns an error because _a_local was only defined as a local variable inside the function a_function so does not exist globally

## --> what happens in the function stays in the function (i.e. overwriting _a_global)
## --> _a_local doesn't persist outside the function (hence the NameError at the end)


# if you assign a variable outside the function it'll still be available inside the function even if you don't assign it inside that function:

_a_global = 10

def a_function():
    """Define a local variable and print its value as well as that of a previously-defined global variable"""
    _a_local = 4
    
    print("Inside the function, the value _a_local is", _a_local)
    print("Inside the function, the value of _a_global is", _a_global)
    
a_function()

print("Outside the function, the value of _a_global is", _a_global)


# to modify/assign a global variable from inside a function, you can use the global keyword:

_a_global = 10

print("Before calling a_function, outside the function, the value of _a_global is", _a_global)

def a_function():
    """Use the 'global' keyword to modify global variable _a_global and assign a new variable _a_local, then print their values"""
    global _a_global
    _a_global = 5
    _a_local = 4
    
    print("Inside the function, the value of _a_global is", _a_global)
    print("Inside the function, the value _a_local is", _a_local)
    
a_function()

print("After calling a_function, outside the function, the value of _a_global now is", _a_global)


# the global keyword also works from inside nested functions:

def a_function():
    """Define the variable _a_global as 10 and define a nested function '_a_function2' which modifies its value using the 'global' keyword, then print the values of _a_global before and after applying the nested function"""
    _a_global = 10

    def _a_function2():
        """Re-assign the value of the variable _a_global to 20 using the 'global' keyword"""
        global _a_global
        _a_global = 20
    
    print("Before calling a_function2, value of _a_global is", _a_global)

    _a_function2()
    
    print("After calling a_function2, value of _a_global is", _a_global)
    
a_function()

print("The value of a_global in main workspace / namespace now is", _a_global)

## --> i.e. using a global keyword inside the inner function _a_function2 resulted in changing the value of _a_global in the main workspace to 20, but within the scope of the _a_function its value remained 10


# compare with this:

_a_global = 10

def a_function():
    """Define a nested function '_a_function2' which reassigns the vale of a variable _a_global to 20. Print the original value of _a_global, then apply the function _a_function2 to it, then print its value after applying this function"""

    def _a_function2():
        """Reassign the value of _a_global as 20"""
        global _a_global
        _a_global = 20
    
    print("Before calling a_function2, value of _a_global is", _a_global)

    _a_function2()
    
    print("After calling a_function2, value of _a_global is", _a_global)

a_function()

print("The value of a_global in main workspace / namespace is", _a_global)

## --> bc _a_global was defined in advance, when _a_function was run:
## - this value was inherited within _a_function from the main workspace
## - it was then given a global designation in the inner function _a_function2
## - then in the inner function _a_function2 when it was changed to a different value it was modified everywhere

**********************************************************************

Testing scope.py...

scope.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 


**********************************************************************
10
9
10
1
Before calling a_function, outside the function, the value of _a_global is 10
Before calling a_function, outside the function, the value of _b_global is 15
Inside the function, the value of _a_global is 4
Inside the function, the value of _b_global is 9
Inside the function, the value of _a_local is 3
After calling a_function, outside the function, the value of _a_global is (still) 10
After calling a_function, outside the function, the value of _b_global is (still) 15
Inside the function
**********************************************************************

Code ran without errors

Time consumed = 0.02674s

======================================================================
Inspecting script file debugme.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
A script saying that it wants you to debug it.
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

def buggyfunc(x):
    y = x
    for i in range(x):
        try: 
            y = y-1
            z = x/y
        except ZeroDivisionError:
            print(f"The result of dividing a number by zero is undefined")
        except:
            print(f"This didn't work;{x = }; {y = }")
        else:
            print(f"OK; {x = }; {y = }, {z = };")
    return z

buggyfunc(20)
**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
OK; x = 20; y = 19, z = 1.0526315789473684;
OK; x = 20; y = 18, z = 1.1111111111111112;
OK; x = 20; y = 17, z = 1.1764705882352942;
OK; x = 20; y = 16, z = 1.25;
OK; x = 20; y = 15, z = 1.3333333333333333;
OK; x = 20; y = 14, z = 1.4285714285714286;
OK; x = 20; y = 13, z = 1.5384615384615385;
OK; x = 20; y = 12, z = 1.6666666666666667;
OK; x = 20; y = 11, z = 1.8181818181818181;
OK; x = 20; y = 10, z = 2.0;
OK; x = 20; y = 9, z = 2.2222222222222223;
OK; x = 20; y = 8, z = 2.5;
OK; x = 20; y = 7, 
**********************************************************************

Code ran without errors

Time consumed = 0.02536s

======================================================================
Inspecting script file lc2.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3

"""
Second practical for Python
"""

__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets

rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.

# for every item in rainfall set if the second element is over 100 it will be in this list comprehension
Over_100 = [i for i in rainfall if (i[1] > 100)] 
print("The answer to the first question is:")
print(Over_100)
print("\n")

# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

#for every item in rainfall set if the second element that is under 50, it will be in this list comprehension
Below_50 = [i for i in rainfall if (i[1] < 50)] 
# next to return the next item from the iterator, zip to take the first element in below 50 and * to take all the element
print("The answer to the second question is:")
print(Below_50) 
print("\n")

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

#create empty sets
task3_1 = [] 
task3_2 = []
# for every number in rainfall set
for i in rainfall: 
    #if second variable(rain) is more than 100
    if i[1] > 100: 
        #append all the those number (and coressponding months toos)
        task3_1.append(i) 
    #else if second variable is less than 50
    elif i[1] < 50:
        # append all those number but only the first element (month name)
        task3_2.append(i) 

print("The answer to the third question is:")
print(task3_1)
print(task3_2)

# A good example output is:
#
# Step #1:
# Months and rainfall values when the amount of rain was greater than 100mm:
# [('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
# ... etc.
**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************
The answer to the first question is:
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]


The answer to the second question is:
[('MAR', 49.9), ('SEP', 27.0)]


The answer to the third question is:
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
[('MAR', 49.9), ('SEP', 27.0)]

**********************************************************************

Code ran without errors

Time consumed = 0.02985s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
NAME
align_seqs_fasta.py

DESCRIPTION
A script to find out the best match of two sequences.

FUNCTIONS
inputs(seq1, seq2)
calculate_score(s1, s2, l1, l2, startpoint)
find_best_alignment(s1, s2, l1, l2)

DATA
command input

VERSION
0.0.1

AUTHOR
Chuxinyao Wang
Sirui Ye (sy1122@ic.ac.uk)
"""

#load packages
import sys



#To start the function:
def inputs(input_file1, input_file2):
    """
    [Calculate tree heights based on distance from tree base and angles from tree top]
    Args:
        seq1
        seq2
       Returns:
        [string]: 2 strings of sequences
        [interger]: 2 lengths of the sequences
    """
    #read the sequences line by line
    with open(input_file1, "r") as f1:
        lines1=f1.readlines()
    with open(input_file2, "r") as f2:
        lines2=f2.readlines()
    ls1=[]
    ls2=[]
    #This is for deleting the info of sequences at line1 also "\n"
    for line in lines1:
        if not line.startswith('>'):
            ls1.append(line.replace('\n',''))
    #Same for another sequences
    for line in lines2:
        if not line.startswith('>'):
            ls2.append(line.replace('\n',''))
    #make seq1&seq2 from lists to strings 
    #to make it easier to align with this:
    seq1 = ''.join(ls1)
    seq2 = ''.join(ls2)
    # Assign the longer sequence s1, and the shorter to s2
    # l1 is length of the longest, l2 that of the shortest
    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths
    
    return s1, s2, l1, l2

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """
    [Calculate similarity score for sequence alignment]
    Args:
        s1: sequence 1
        s2: sequence 2
        l1: sequence 1 length
        l2: sequence 2 length
        startpoint
       Returns:
        [interger]: score
    """
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    return score

# now try to find the best match (highest score) for the two sequences
def find_best_alignment(s1, s2, l1, l2):
    """
    [Find the alignment of the two sequences that gives the best match and highest score]
    Args:
        s1: sequence 1
        s2: sequence 2
        l1: sequence 1 length
        l2: sequence 2 length
       Returns:
        [interger]: best score
        [string]: best alignment
    """
    my_best_align = None
    my_best_score = -1

    for i in range(l1): # Note that you just take the last alignment with the highest score
        z = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score:
            my_best_align = "." * i + s2 # "." indicates start point
            my_best_score = z 

    print("The highest score is:", my_best_score)
    print("The best alignment is", my_best_align)
    
    return my_best_align, my_best_score


def main(argv):
    """Main entry point of the program: 
    reads in files, calculates the best match, 
    and saves results to output files"""
    
    # if no arguments given, use default files
    if len(sys.argv) != 3:
        input_file1 = "../data/407228326.fasta"
        input_file2 = "../data/407228412.fasta"
        
    else:# take from command line
        input_file1 = sys.argv[1]
        input_file2 = sys.argv[2]

    # Run inputs(seq1, seq2) to find out the longer sequence
    s1, s2, l1, l2 = inputs(input_file1, input_file2)

    # Run find_best_align to find best alignment of sequences
    my_best_align, my_best_score = find_best_alignment(s1, s2, l1, l2)

    # Output file
    with open("../results/align_seq_fasta.txt", "w") as f:
         f.write("my_best_align" + my_best_align)
         f.write("\n")
         f.write("\nBest score: " + str(my_best_score))
         print("Your results can be found in the results directory!")

    return None




if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.5

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/PasithPrayoonrat_/Week2/code/align_seqs_fasta.py", line 161, in <module>
    status = main(sys.argv)
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/PasithPrayoonrat_/Week2/code/align_seqs_fasta.py", line 143, in main
    s1, s2, l1, l2 = inputs(input_file1, input_file2)
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/PasithPrayoonrat_/Week2/code/align_seqs_fasta.py", line 42, in inputs
    with open(input_file1, "r") as f1:
FileNotFoundError: [Errno 2] No such file or directory: '../data/407228326.fasta'

======================================================================
Inspecting script file control_flow.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
Some functions exemplifying the use of control statements
"""
__author__ = 'Pasith Prayoorat(pp1922@ic.ac.uk'
__version__ = '0.0.1'

import sys

def even_or_odd(x=0): # if not specified, x should take value 0.

    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if
        return f"{x} is Even!"
    return f"{x} is Odd!"

def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return f"No divisor found for {x}!" # Each function can return a value or a variable.
    return f"The largest divisor of {x} is {largest}"

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
            print(f"{x} is not a prime: {i} is a divisor") 
            return False
    print(f"{x} is a prime!")
    return True 

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
        if is_prime(i):
            allprimes.append(i)
    print(f"There are {len(allprimes)} primes between 2 and {x}")
    return allprimes
      
def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 99.0

Output (only first 500 characters): 


**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.02686s

======================================================================
Inspecting script file loops.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
A script containing loop examples.
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

# FOR loops
for i in range(5):
    print(i)

my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

# WHILE loop
z = 0
while z < 100:
    z = z + 1
    print(z)
**********************************************************************

Testing loops.py...

loops.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.0

Output (only first 500 characters): 


**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100

**********************************************************************

Code ran without errors

Time consumed = 0.02992s

======================================================================
Inspecting script file basic_io3.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
How to store file in python.
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again
f = open('../sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)

**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 99.0

Output (only first 500 characters): 


**********************************************************************
{'a key': 10, 'another key': 11}

**********************************************************************

Code ran without errors

Time consumed = 0.03195s

======================================================================
Inspecting script file cfexercises1.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
Different foo function examples.
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'


import sys #import the system

def foo_1(x = 5): #if not specified x should take the value of 5 for reasons
    """Calculate the square root of x"""
    y = x ** 0.5
    return " The square root of %d is %d" % (x , y)

def foo_2(x = 5, y = 2): # x = 5 and y = 2 is the default
    """If x is more than y, return y"""
    if x > y:
        return "%d is the higher number." % x
    return "%d is the higher number." % y

def foo_3(x = 4, y = 5, z = 6): # 4,5,6 is the default
    """ Put x, y, and z in an order from lowest to the highest."""
    if x > y:
        tmp = y
        y = x
        x = tmp
    if y > z:
        tmp = z
        z = y
        y = tmp
    return "Lowest number is %d. Second from highest number is %d. Highest number is %d." % (x, y, z)

def foo_4(x = 6): # 6 is the default
    """Factorial of x"""
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return "Factorial of %d is %d" % (x, result)

def foo_5(x = 10 ): #10 is the default
    """ A recursive function that calculates the factorial of x """
    if x == 1:
        return 1
    return x * foo_5(x - 1)
     
def foo_6(x = 5):
    """Calculate the factorial of x in a different way; no if statement involved """
    facto = 1
    while x >= 1:#
        facto = facto * x
        x = x - 1
    return facto

#functions testing 

def main(argv):
    """Entry point"""
    print(foo_1(5))
    print(foo_2(5, 2))
    print(foo_3(4, 5, 6))
    print(foo_4(5))
    print(foo_5(10))
    print(foo_6(5))
    return 0
#makes sure the file is usable and importable
if __name__ == "__main__":
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 99.0

Output (only first 500 characters): 


**********************************************************************
 The square root of 5 is 2
5 is the higher number.
Lowest number is 4. Second from highest number is 5. Highest number is 6.
Factorial of 5 is 120
3628800
120

**********************************************************************

Code ran without errors

Time consumed = 0.03058s

======================================================================
Inspecting script file oaks.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
Functions designed to determine whether a species is an oak.
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

## Finds just those taxa that are oak trees from a list of species

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

def is_an_oak(name):
    return name.lower().startswith('quercus ')

##Using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

##Using list comprehensions   
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

##Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)
**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 98.5

Output (only first 500 characters): 


**********************************************************************
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'QUERCUS PETRAEA', 'QUERCUS ROBUR', 'QUERCUS CERRIS'}
{'QUERCUS PETRAEA', 'QUERCUS ROBUR', 'QUERCUS CERRIS'}

**********************************************************************

Code ran without errors

Time consumed = 0.03060s

======================================================================
Inspecting script file align_seqs_better.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
NAME
align_seqs_fasta.py

DESCRIPTION
A script to find out all the equally-best alignments.

FUNCTIONS
inputs(seq1, seq2)
calculate_score(s1, s2, l1, l2, startpoint)
find_best_alignment(s1, s2, l1, l2)

DATA
command input

VERSION
0.0.1

AUTHOR
Chuxinyao Wang
Sirui Ye (sy1122@ic.ac.uk)
"""


#load packages
import sys
import pickle



#To start the function:
def inputs(input_file1, input_file2):
    """
    [Calculate tree heights based on distance from tree base and angles from tree top]
    Args:
        seq1
        seq2
       Returns:
        [string]: 2 strings of sequences
        [interger]: 2 lengths of the sequences
    """
    #read the sequences line by line
    with open(input_file1, "r") as f1:
        lines1=f1.readlines()
    with open(input_file2, "r") as f2:
        lines2=f2.readlines()
    ls1=[]
    ls2=[]
    #This is for deleting the info of sequences at line1 also "\n"
    for line in lines1:
        if not line.startswith('>'):
            ls1.append(line.replace('\n',''))
    #Same for another sequences
    for line in lines2:
        if not line.startswith('>'):
            ls2.append(line.replace('\n',''))
    #make seq1&seq2 from lists to strings 
    #to make it easier to align with this:
    seq1 = ''.join(ls1)
    seq2 = ''.join(ls2)
    # Assign the longer sequence s1, and the shorter to s2
    # l1 is length of the longest, l2 that of the shortest
    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths
    
    return s1, s2, l1, l2

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """
    [Calculate similarity score for sequence alignment]
    Args:
        s1: sequence 1
        s2: sequence 2
        l1: sequence 1 length
        l2: sequence 2 length
        startpoint
       Returns:
        [interger]: score
    """
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    return score

# now try to find the best match (highest score) for the two sequences
def find_best_alignment(s1, s2, l1, l2):
    """
    [Find the alignment of the two sequences that gives the best match and highest score]
    Args:
        s1: sequence 1
        s2: sequence 2
        l1: sequence 1 length
        l2: sequence 2 length
       Returns:
        [interger]: best score
        [string]: best alignment
    """
    my_best_align = None
    my_best_score = -1
    best_score_collection = list()
    best_align_collection = list()

    # calculate score for each alignment
    for i in range(l1): 
        z = calculate_score(s1, s2, l1, l2, i)
        best_score_collection.append(z)
    
    # find out the best score
    my_best_score  = max(best_score_collection)  

    # find the best alignment
    for i in range(l1):
        if best_score_collection[i] == my_best_score:
            my_best_align = "." * i + s2 # "." indicates start point
            best_align_collection.append(my_best_align)
            
    best_results = dict()
    best_results[my_best_score] = [best_align_collection]

    print("The highest score is:", my_best_score)
    print("The best alignment is", best_align_collection)

    with open('../results/align_seqs_better.pickle', 'wb') as f:
        print ("======storing the result=====")
        pickle.dump(best_results, f)
    
    return best_results


def main(argv):
    """Main entry point of the program: 
    reads in files, calculates the best match, 
    and saves results to output files"""
    
    # if no arguments given, use default files
    if len(sys.argv) != 3:
        input_file1 = "../data/407228326.fasta"
        input_file2 = "../data/407228412.fasta"
        
    else:# take from command line
        input_file1 = sys.argv[1]
        input_file2 = sys.argv[2]

    # Run inputs(seq1, seq2) to find out the longer sequence
    s1, s2, l1, l2 = inputs(input_file1, input_file2)

    # Run find_best_align to find best alignment of sequences
    best_results = find_best_alignment(s1, s2, l1, l2)
    my_best_score = best_results.keys()
    best_align_collection = best_results.values()


    # Output file
    with open("../results/align_seq_fasta.txt", "w") as f:
         f.write("best_align_collection" + str(best_align_collection))
         f.write("\n")
         f.write("\nBest score: " + str(my_best_score))
         print("Your results can be found in the results directory!")

    return None




if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)



**********************************************************************

Testing align_seqs_better.py...

align_seqs_better.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 98.5

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/PasithPrayoonrat_/Week2/code/align_seqs_better.py", line 183, in <module>
    status = main(sys.argv)
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/PasithPrayoonrat_/Week2/code/align_seqs_better.py", line 162, in main
    s1, s2, l1, l2 = inputs(input_file1, input_file2)
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2022-23/Coursework/StudentRepos/PasithPrayoonrat_/Week2/code/align_seqs_better.py", line 44, in inputs
    with open(input_file1, "r") as f1:
FileNotFoundError: [Errno 2] No such file or directory: '../data/407228326.fasta'

======================================================================
Inspecting script file align_seqs.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
This script is designed to align DNA sequences to the closest possible match
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

#import ipdb #debugger
import csv #use to read csv file
import sys #import the system

#ipdb.set_trace() #the breakpoint
#open the csv file
DNAs_open = open('../data/DNAs.csv', 'r') 

#read the .csv DNA file
read_csv = csv.reader(DNAs_open) 
DNA = []
for row in read_csv:
    DNA.append(row[0])

DNA_1 = str(DNA[1])
DNA_2 = str(DNA[0])

# Two example sequences to match

# Assign the longer sequence s1, and the shorter to s2

#use len to find the length of both DNA
l1 = len(DNA_2)
l2 = len(DNA_1)
if l1 >= l2: # if seq1 length is longer than seq2
    s1 = DNA_2 
    s2 = DNA_1 
else:# if seq2 length is shorter than seq1, s1 will always be the longer sequence
    s1 = DNA_1 
    s2 = DNA_2 
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint): 
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# ca lculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1

for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 
print(my_best_align)
print(s1)
print("Best score:", my_best_score) 

#use text file in result as an output
sys.stdout = open ('../results/align_seq_result.txt', 'w') 
print ("The best alignment is: " + str(my_best_align) + "." "The best score is: " + str(my_best_score) + ".")

#confirmation to close
sys.stdout.close() 
**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 98.0

Output (only first 500 characters): 


**********************************************************************
------*--*
CAATTCGGAT
TCGCCGGATTACGGG
2
 
.*---------
.CAATTCGGAT
TCGCCGGATTACGGG
1
 
..--------*-
..CAATTCGGAT
TCGCCGGATTACGGG
1
 
...*---------
...CAATTCGGAT
TCGCCGGATTACGGG
1
 
....*---*-----
....CAATTCGGAT
TCGCCGGATTACGGG
2
 
.....--***--*--
.....CAATTCGGAT
TCGCCGGATTACGGG
4
 
......-*-*-***-
......CAATTCGGAT
TCGCCGGATTACGGG
5
 
.......------**
.......CAATTCGGAT
TCGCCGGATTACGGG
2
 
........--*---*
........CAATTCGGAT
TCGCCGGATTACGGG
2
 
.........-*----
.........CAATTCGGAT
TCGCCGGATTACGGG
1
 
.
**********************************************************************

Code ran without errors

Time consumed = 0.02612s

======================================================================
Inspecting script file using_name.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
A script containing the use of a main module.
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

# Filename: using_name.py

if __name__ == '__main__':
    print('This program is being run by itself')
else:
    print('I am being imported from another module')
    
print("This module's name is: " + __name__)
**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 98.0

Output (only first 500 characters): 


**********************************************************************
This program is being run by itself
This module's name is: __main__

**********************************************************************

Code ran without errors

Time consumed = 0.02572s

======================================================================
Inspecting script file dictionary.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
Fourth Practical for Python
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

#from operator import add

import sys

taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a python script to populate a dictionary called taxa_dic derived from
# taxa so that it maps order names to sets of taxa and prints it to screen.
# 
# An example output is:
# 
# 'Chiroptera' : set(['Myotis lucifugus']) ... etc. OR, 'Chiroptera': {'Myotis
#  lucifugus'} ... etc

#### Your solution here #### 


#solution

#create taxa _dic as a dictionary
taxa_dic = dict() 
#create the genus set key as a set of genus names from the second variables in the taxa list
genus_set = set([x[1] for x in taxa]) 
#for every item in the genus_set
for x in genus_set: 
        # set a new variable (y) as the value for the first element of the taxa list if the second element is match with the genus_set name to avoid duplication/overwriting
        taxa_dic[x] = set([y[0] for y in taxa if y[1] == x]) 

#beautiful
from pprint import pprint
pprint(taxa_dic)


# Now write a list comprehension that does the same (including the printing after the dictionary has been created)  

#### Your solution here #### 

#create a new list comprehension, set the key as  the second variable in the taxa list and the value as the first variable in the taxa list
taxa_dic_lc = {x[1]:[y[0] for y in taxa if y[1] == x[1]] for x in taxa} 
#if the key in the first list matches the genus on the list, it will be assign as a value for that key

from pprint import pprint
pprint(taxa_dic_lc)
**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 98.0

Output (only first 500 characters): 


**********************************************************************
{'Afrosoricida': {'Microgale talazaci', 'Microgale dobsoni'},
 'Carnivora': {'Canis lupus', 'Arctocephalus gazella', 'Lyacon pictus'},
 'Chiroptera': {'Myotis lucifugus'},
 'Rodentia': {'Cleithrionomys rutilus',
              'Gerbillus henleyi',
              'Mus domesticus',
              'Peromyscus crinitus'}}
{'Afrosoricida': ['Microgale dobsoni', 'Microgale talazaci'],
 'Carnivora': ['Lyacon pictus', 'Arctocephalus gazella', 'Canis lupus'],
 'Chiroptera': ['Myotis lucifugus'],
 'Rodentia':
**********************************************************************

Code ran without errors

Time consumed = 0.04340s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
Some functions exemplifying the use of control statements
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

import sys
import doctest # Import the doctest module

def even_or_odd(x=0):
    """Find whether a number x is even or odd

    >>> even_or_odd(10)
    '10 is Even!'

    >>> even_or_odd(5)
    '5 is Odd!'

    whenever a float is provided, then the closest integer is used:
    >>> even_or_odd(3)
    '3 is Odd!'

    in case of negative numbers, the positive is taken:
    >>> even_or_odd(-2)
    '-2 is Even!'

    in case of negative numbers, the positive is taken:
    >>> even_or_odd(-2)
    '-2 is Even!'

     """
    #Define function to be tested
    if x % 2 == 0:
        return f"{x} is Even!"
    return f"{x} is Odd!"

def main(argv): 
    print(even_or_odd(22))
    print(even_or_odd(33))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)

doctest.testmod()   # To run with embedded tests

**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 97.5

Output (only first 500 characters): 


**********************************************************************
22 is Even!
33 is Odd!

**********************************************************************

Code ran without errors

Time consumed = 0.05643s

======================================================================
Inspecting script file sysargv.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
A script contataining sys.argv in Python explaining the basics of it.
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: ", str(sys.argv))
**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 97.5

Output (only first 500 characters): 


**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.02798s

======================================================================
Inspecting script file tuple.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
Third practical for Python
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by
# species 
 # for the first item, second item and third item in the nested tuple 
for x,y,z in birds:
    #print \n to seperate by line break
    print("Latin_name: " + str(x) + "\n"  +  "Common_name: " + str(y) + "\n" + "Mass: " + str(z) + "\n") 

# A nice example output is:
# 
# Latin name: Passerculus sandwichensis Common name: Savannah sparrow Mass: 18.7
# ... etc.
**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 97.5

Output (only first 500 characters): 


**********************************************************************
Latin_name: Passerculus sandwichensis
Common_name: Savannah sparrow
Mass: 18.7

Latin_name: Delichon urbica
Common_name: House martin
Mass: 19

Latin_name: Junco phaeonotus
Common_name: Yellow-eyed junco
Mass: 19.5

Latin_name: Junco hyemalis
Common_name: Dark-eyed junco
Mass: 19.6

Latin_name: Tachycineata bicolor
Common_name: Tree swallow
Mass: 20.2


**********************************************************************

Code ran without errors

Time consumed = 0.02760s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
Different hello function examples.
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

########################
def hello_1(x):
    for j in range(x):
        if j % 3 == 0:
            print('hello')
    print(' ')

hello_1(12)

########################
def hello_2(x):
    for j in range(x):
        if j % 5 == 3:
            print('hello')
        elif j % 4 == 3:
            print('hello')
    print(' ')

hello_2(12)

########################
def hello_3(x, y):
    for i in range(x, y):
        print('hello')
    print(' ')

hello_3(3, 17)

########################
def hello_4(x):
    while x != 15:
        print('hello')
        x = x + 3
    print(' ')

hello_4(0)

########################
def hello_5(x):
    while x < 100:
        if x == 31:
            for k in range(7):
                print('hello')
        elif x == 18:
            print('hello')
        x = x + 1
    print(' ')

hello_5(12)

# WHILE loop with BREAK
def hello_6(x, y):
    while x: # while x is True
        print("hello! " + str(y))
        y += 1 # increment y by 1 
        if y == 6:
            break
    print(' ')

hello_6 (True, 0)
**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 94.5

Output (only first 500 characters): 


**********************************************************************
hello
hello
hello
hello
 
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
 
hello
hello
hello
hello
hello
hello
hello
hello
 
hello! 0
hello! 1
hello! 2
hello! 3
hello! 4
hello! 5
 

**********************************************************************

Code ran without errors

Time consumed = 0.02726s

======================================================================
Inspecting script file basic_io1.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
A script showing how to input a file in python.
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

f = open('../sandbox/test.txt', 'r')

for line in f:
    print(line)

f.close()

f = open('../sandbox/test.txt', 'r')

for line in f:
    print(line)

f.close()

f = open('../sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0:
        print(line)

f.close()
**********************************************************************

Testing basic_io1.py...

basic_io1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 94.5

Output (only first 500 characters): 


**********************************************************************
First Line

Second Line 



Third Line



Fourth Line
First Line

Second Line 



Third Line



Fourth Line
First Line

Second Line 

Third Line

Fourth Line

**********************************************************************

Code ran without errors

Time consumed = 0.03617s

======================================================================
Inspecting script file basic_io2.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
A script showing how to output a file in python.
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

#############################
# FILE OUTPUT
#############################
# Save the elements of a list to a file
list_to_save = range(100)

f = open('../sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end

f.close()
**********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 94.5

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.03033s

======================================================================
Inspecting script file boilerplate.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""Boilerplate for Python"""    
"""Description of this program or application.
You can use several lines"""
__appname__ = '[application name here]'
__author__ = 'Your Name (your@email.address)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ##
import sys # module to interface our program with the operating system

## constants ##


## functions ##
def main(argv):
    """ Main entry point of the program """
    print('This is a boilerplate') # NOTE: indented using two tabs or 4 spaces
    return 0

if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""  
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 94.5

Output (only first 500 characters): 


**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.03331s

======================================================================
Inspecting script file MyExampleScript.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
An example python script
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

def foo(x): # a simple script of a function called foo(x)
    x *= x # same as x = x*x
    print(x)

foo(2) #example of how to call a function 
**********************************************************************

Testing MyExampleScript.py...

MyExampleScript.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 94.0

Output (only first 500 characters): 


**********************************************************************
4

**********************************************************************

Code ran without errors

Time consumed = 0.02822s

======================================================================
Inspecting script file lc1.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
First Practical for Python
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 

from pprint import pprint #pprint for better visualization

Latin_names = [x[0] for x in birds] #takes the first element from the birds list and seperate it into a new list called Latin_names
pprint(Latin_names)

Common_names = [x[1] for x in birds]
pprint(Common_names)

Body_masses = [x[2] for x in birds]
pprint(Body_masses)

# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 

#creates a blank set to insert the output in
Loop_one = []
#for every item in birds
for x in birds: 
#append all the first variable in each of the nested tuple (the latin name)
    Loop_one.append(x[0]) 
#print it
pprint(Loop_one) 

#creates a blank set to insert the output in
Loop_two = [] 
# for every item in birds
for x in birds: 
    # append all the second variables in each of the nested tuple (common name)
    Loop_two.append(x[1]) 
pprint(Loop_two)

#creates a blank set to insert the output in
Loop_three=[] 
# for every item in bird
for x in birds: 
    #append all the third variables in each of the nested tuple (bodymass)
    Loop_three.append(x[2]) 
pprint(Loop_three)


# A nice example out out is:
# Step #1:
# Latin names:
# ['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
# ... etc.
**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 94.0

Output (only first 500 characters): 


**********************************************************************
['Passerculus sandwichensis',
 'Delichon urbica',
 'Junco phaeonotus',
 'Junco hyemalis',
 'Tachycineata bicolor']
['Savannah sparrow',
 'House martin',
 'Yellow-eyed junco',
 'Dark-eyed junco',
 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]
['Passerculus sandwichensis',
 'Delichon urbica',
 'Junco phaeonotus',
 'Junco hyemalis',
 'Tachycineata bicolor']
['Savannah sparrow',
 'House martin',
 'Yellow-eyed junco',
 'Dark-eyed junco',
 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]

**********************************************************************

Code ran without errors

Time consumed = 0.03943s

======================================================================
Inspecting script file basic_csv.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
Basic script to read the species name from the testcsv.csv in data and write a file called bodymass.csv in the data folder. 
"""
__author__ = 'Pasith Prayoonrat (pp1922@ic.ac.uk)'
__version__ = '0.0.1'

import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
with open('../data/testcsv.csv','r') as f:

    csvread = csv.reader(f)
    temp = []
    for row in csvread:
        temp.append(tuple(row))
        print(row)
        print("The species is", row[0])

# write a file containing only species name and Body mass
with open('../data/testcsv.csv','r') as f:
    with open('../data/bodymass.csv','w') as g:

        csvread = csv.reader(f)
        csvwrite = csv.writer(g)
        for row in csvread:
            print(row)
            csvwrite.writerow([row[0], row[4]])

**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 94.0

Output (only first 500 characters): 


**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagasc
**********************************************************************

Code ran without errors

Time consumed = 0.02580s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""
A practical problem on debugging of a function that determine whether a species is an oak.
"""
__author__ = 'Dashing Dingos'
__version__ = '0.0.1'

import csv #import csv
import sys
import doctest

#Define function
#import ipdb; ipdb.set_trace()
def is_an_oak(name):

    """ Returns True if name is starts with 'quercus'
    >>> is_an_oak('Fagus sylvatica') #wrong name
    False
    >>> is_an_oak('Quercus robur') #Capital letter
    True
    >>> is_an_oak('quercus robur') #correct !
    True
    >>> is_an_oak('quercuss robur') #typo 
    True
    """
    return name.lower().startswith('quercus')
doctest.testmod()

def main(argv): 
    """ Exclude the header row and include the column headers. """ 
    f = open('../data/TestOaksData.csv','r')
    g = open('../results/JustOaksData.csv','w')
    taxa = csv.reader(f)
    #use this to exclude the header
    next(taxa)
    csvwrite = csv.writer(g)
    oaks = set()
    for row in taxa:
        #print the species
        print(row)
        print("The genus is: ")
        print(row[0])
        #if it is an oak
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
        #if not
        else:
            print("NOT AN OAK!\n")
            csvwrite.writerow([row[0], row[1]])
    print("\nOaks saved to ../results/JustOaksData.csv")
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 94.0

Output (only first 500 characters): 


**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus
FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus
NOT AN OAK!

['Pinus', ' sylvestris']
The genus is: 
Pinus
NOT AN OAK!

['Quercus', ' cerris']
The genus is: 
Quercus
FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus
FOUND AN OAK!


Oaks saved to ../results/JustOaksData.csv

**********************************************************************

Code ran without errors

Time consumed = 0.05129s

======================================================================
======================================================================
Finished running scripts

Ran into 2 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 94.0

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!