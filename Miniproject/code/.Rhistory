Initial_value[i,2] <- min(temp_df$LOGPopBio)
#K_start- Population
Initial_value[i,3] <- max(temp_df$LOGPopBio)
#Rmax- Gausian distribution.
Initial_value[i,4] <- runif(1, min = 10^-10, max = 10^-2)
#t_lag_start -lag phase last time point
Initial_value[i,5] <- temp_df$Time[which.max(diff(diff(temp_df$LOGPopBio)))]
}
Initial_value[is.na(Initial_value) | Initial_value == "Inf" | Initial_value == "-Inf"] <- NA
#for each unique ID in the data
for (i in unique(data$ID)){
#browser()
#creates a temporary dataframe
temp_df <- data[which(data$ID == i),]
#creates a log stat dataframe to store different tries in each loop
log_stats <- data.frame(AIC = rep(NA, 100),
BIC = rep(NA ,100),
rmax = rep(NA, 100),
K = rep(NA, 100),
N0 = rep(NA, 100))
gomp_stats <- data.frame(AIC = rep(NA, 100),
BIC = rep(NA ,100),
rmax = rep(NA, 100),
K = rep(NA, 100),
N0 = rep(NA, 100),
t_lag = rep(NA, 100))
replicate(100, {
N0 <- rnorm(1, mean = Initial_value$N0[1], sd = 1)
K <- rnorm(1, mean = Initial_value$K[1], sd = 1)
rmax <- runif(1, min = 10^-10, max = 10^-2)
t_lag <- rnorm(1, mean = Initial_value$t_lag[1], sd = 1)
})
######Linear Model######
#quadratic linear model
tryCatch(
q_model <- lm(temp_df$PopBio ~ poly(temp_df$Time, 2, raw = TRUE))
)
#cubic linear model
tryCatch(
c_model <- lm(temp_df$PopBio ~ poly(temp_df$Time, 3, raw = TRUE))
)
#cat("Starting Model Fitting \n")
for (j in 1:100){
####nonlinear model######
tryCatch(
{
l_model <- nlsLM(temp_df$PopBio ~ logistic_model(t = Time, rmax, K ,N0), temp_df,
start = list(rmax = rmax[j],
N0 = N0[j],
K = K[j]),
control = nls.lm.control(maxiter = 100))
log_stats[j,] <- c(aic_function(l_model, temp_df),
bic_function(l_model, temp_df),
coef(l_model)["rmax"],
coef(l_model)["K"],
coef(l_model)["N0"])
},error = function(e){log_stats[j,] <- c(rep(NA,5))},
silent = TRUE)
#store the best replication (the one with the lowest AIC) in a log best dataframe
try(log_best <- subset(log_stats, log_stats$AIC == min(log_stats$AIC, na.rm = TRUE)))
#Gompertz
tryCatch(
{
g_model <- nlsLM(temp_df$LOGPopBio ~ gompertz_model(t = Time, rmax, K, N0, t_lag), temp_df,
start = list(rmax = rmax[j],
K = K[j],
N0 = N0[j],
t_lag = t_lag[j]),
control = nls.lm.control(maxiter = 100))
gomp_stats[j,] <- c(aic_function_forG(g_model, temp_df),
bic_function_forG(g_model, temp_df),
coef(g_model)["rmax"],
coef(g_model)["K"],
coef(g_model)["N0"],
coef(g_model)["t_lag"])
}, error = function(e){gomp_stats[j,] <- c(rep(NA, 6))},
slient = TRUE)
try(gomp_best <- subset(gomp_stats, gomp_stats$AIC == min(gomp_stats$AIC, na.rm = TRUE)))
}
#put everyting in the same pre-allocated dataframe
#Qudratic
try(pre_df$Q_AIC[i] <- aic_function(q_model, temp_df))
try(pre_df$Q_BIC[i] <- bic_function(q_model, temp_df))
try(pre_df$Q_intercept[i] <- coef(q_model)[1])
try(pre_df$Q_slope[i] <- coef(q_model)[2])
#Cubic
try(pre_df$C_AIC[i] <- aic_function(c_model, temp_df))
try(pre_df$C_BIC[i] <- bic_function(c_model, temp_df))
try(pre_df$C_intercept[i] <- coef(c_model)[1])
try(pre_df$C_slope[i] <- coef(c_model)[2])
#use silent = TRUE cause some might not fit
#Logistic
try((pre_df$L_AIC[i] <- log_best$AIC), silent = TRUE)
try((pre_df$L_BIC[i] <- log_best$BIC), silent = TRUE)
try((pre_df$L_K[i] <- log_best$K), silent = TRUE)
try((pre_df$L_Rmax[i] <- log_best$rmax), silent = TRUE)
try((pre_df$L_N0[i] <- log_best$N0), silent = TRUE)
#Gompertz
try((pre_df$G_AIC[i] <- gomp_best$AIC), silent = TRUE)
try((pre_df$G_BIC[i] <- gomp_best$BIC), silent = TRUE)
try((pre_df$G_K[i] <- gomp_best$K), silent = TRUE)
try((pre_df$G_N0[i] <- gomp_best$N0), silent = TRUE)
try((pre_df$G_rmax[i] <- gomp_best$rmax), silent = TRUE)
try((pre_df$G_tlag[i] <- gomp_best$t_lag), silent = TRUE)
}
View(pre_df)
setwd("Documents/CMEECourseWork/Miniproject/code")
rm(list=ls())
graphics.off()
source("functions.R")
#nlsLM
library("minpack.lm")
cat("Preallocating Dataframes")
data <- read.csv("../data/Wrangled_Data.csv", header = TRUE)
#replace Inf and -Inf to NA
data[is.na(data) | data == "Inf" | data == "-Inf"] <- NA
pre_df <- data.frame(#Unique IDs
ID = c(1:285),
#Quadratic
Q_AIC = rep(0,285),
Q_BIC = rep(0,285),
Q_intercept = rep(0,285),
Q_slope = rep(0,285),
#Cubic
C_AIC = rep(0,285),
C_BIC = rep(0,285),
C_intercept = rep(0,285),
C_slope = rep(0,285),
#Logistic
L_AIC = rep(0,285),
L_BIC = rep(0,285),
L_Rmax = rep(0,285),
L_K = rep(0,285),
L_N0 = rep(0,285),
#Gompertz
G_AIC = rep(0,285),
G_BIC = rep(0,285),
G_rmax = rep(0,285),
G_K = rep(0,285),
G_N0 = rep(0,285),
G_tlag = rep(0,285)
)
#create an initial value
Initial_value <- data.frame(ID = c(1:285),
N0 = rep(0,285),
K = rep(0,285),
rmax = rep(0,285),
t_lag = rep(0,285))
#log the PopBio data
data$LOGPopBio <- log10(data$PopBio)
#same randomization
set.seed(1234)
#create unique subset for each unique IDs
for (i in unique(Initial_value$ID)){
#creates a temporary dataframes for each unique ID
temp_df <- subset(data, data$ID == i)
#each unique IDs
Initial_value[i,1] <- i
#N_start - initial Population
Initial_value[i,2] <- min(temp_df$LOGPopBio)
#K_start- Population
Initial_value[i,3] <- max(temp_df$LOGPopBio)
#Rmax- Gausian distribution.
Initial_value[i,4] <- runif(1, min = 10^-10, max = 10^-2)
#t_lag_start -lag phase last time point
Initial_value[i,5] <- temp_df$Time[which.max(diff(diff(temp_df$LOGPopBio)))]
}
Initial_value[is.na(Initial_value) | Initial_value == "Inf" | Initial_value == "-Inf"] <- NA
#for each unique ID in the data
for (i in unique(data$ID)){
browser()
#creates a temporary dataframe
temp_df <- data[which(data$ID == i),]
#creates a log stat dataframe to store different tries in each loop
log_stats <- data.frame(AIC = rep(NA, 100),
BIC = rep(NA ,100),
rmax = rep(NA, 100),
K = rep(NA, 100),
N0 = rep(NA, 100))
gomp_stats <- data.frame(AIC = rep(NA, 100),
BIC = rep(NA ,100),
rmax = rep(NA, 100),
K = rep(NA, 100),
N0 = rep(NA, 100),
t_lag = rep(NA, 100))
N0 <- rnorm(100, mean = Initial_value$N0[1], sd = 1)
K <- rnorm(100, mean = Initial_value$K[1], sd = 1)
rmax <- rnorm(100, min = 10^-10, max = 10^-2, sd = 1)
t_lag <- rnorm(100, mean = Initial_value$t_lag[1], sd = 1)
######Linear Model######
#quadratic linear model
tryCatch(
q_model <- lm(temp_df$PopBio ~ poly(temp_df$Time, 2, raw = TRUE))
)
#cubic linear model
tryCatch(
c_model <- lm(temp_df$PopBio ~ poly(temp_df$Time, 3, raw = TRUE))
)
#cat("Starting Model Fitting \n")
for (j in 1:100){
####nonlinear model######
tryCatch(
{
l_model <- nlsLM(temp_df$PopBio ~ logistic_model(t = Time, rmax, K ,N0), temp_df,
start = list(rmax = rmax[j],
N0 = N0[j],
K = K[j]),
control = nls.lm.control(maxiter = 100))
log_stats[j,] <- c(aic_function(l_model, temp_df),
bic_function(l_model, temp_df),
coef(l_model)["rmax"],
coef(l_model)["K"],
coef(l_model)["N0"])
},error = function(e){log_stats[j,] <- c(rep(NA,5))},
silent = TRUE)
#store the best replication (the one with the lowest AIC) in a log best dataframe
try(log_best <- subset(log_stats, log_stats$AIC == min(log_stats$AIC, na.rm = TRUE)))
#Gompertz
tryCatch(
{
g_model <- nlsLM(temp_df$LOGPopBio ~ gompertz_model(t = Time, rmax, K, N0, t_lag), temp_df,
start = list(rmax = rmax[j],
K = K[j],
N0 = N0[j],
t_lag = t_lag[j]),
control = nls.lm.control(maxiter = 100))
gomp_stats[j,] <- c(aic_function_forG(g_model, temp_df),
bic_function_forG(g_model, temp_df),
coef(g_model)["rmax"],
coef(g_model)["K"],
coef(g_model)["N0"],
coef(g_model)["t_lag"])
}, error = function(e){gomp_stats[j,] <- c(rep(NA, 6))},
slient = TRUE)
try(gomp_best <- subset(gomp_stats, gomp_stats$AIC == min(gomp_stats$AIC, na.rm = TRUE)))
}
#put everyting in the same pre-allocated dataframe
#Qudratic
try(pre_df$Q_AIC[i] <- aic_function(q_model, temp_df))
try(pre_df$Q_BIC[i] <- bic_function(q_model, temp_df))
try(pre_df$Q_intercept[i] <- coef(q_model)[1])
try(pre_df$Q_slope[i] <- coef(q_model)[2])
#Cubic
try(pre_df$C_AIC[i] <- aic_function(c_model, temp_df))
try(pre_df$C_BIC[i] <- bic_function(c_model, temp_df))
try(pre_df$C_intercept[i] <- coef(c_model)[1])
try(pre_df$C_slope[i] <- coef(c_model)[2])
#use silent = TRUE cause some might not fit
#Logistic
try((pre_df$L_AIC[i] <- log_best$AIC), silent = TRUE)
try((pre_df$L_BIC[i] <- log_best$BIC), silent = TRUE)
try((pre_df$L_K[i] <- log_best$K), silent = TRUE)
try((pre_df$L_Rmax[i] <- log_best$rmax), silent = TRUE)
try((pre_df$L_N0[i] <- log_best$N0), silent = TRUE)
#Gompertz
try((pre_df$G_AIC[i] <- gomp_best$AIC), silent = TRUE)
try((pre_df$G_BIC[i] <- gomp_best$BIC), silent = TRUE)
try((pre_df$G_K[i] <- gomp_best$K), silent = TRUE)
try((pre_df$G_N0[i] <- gomp_best$N0), silent = TRUE)
try((pre_df$G_rmax[i] <- gomp_best$rmax), silent = TRUE)
try((pre_df$G_tlag[i] <- gomp_best$t_lag), silent = TRUE)
}
#for each unique ID in the data
for (i in unique(data$ID)){
#browser()
#creates a temporary dataframe
temp_df <- data[which(data$ID == i),]
#creates a log stat dataframe to store different tries in each loop
log_stats <- data.frame(AIC = rep(NA, 100),
BIC = rep(NA ,100),
rmax = rep(NA, 100),
K = rep(NA, 100),
N0 = rep(NA, 100))
gomp_stats <- data.frame(AIC = rep(NA, 100),
BIC = rep(NA ,100),
rmax = rep(NA, 100),
K = rep(NA, 100),
N0 = rep(NA, 100),
t_lag = rep(NA, 100))
N0 <- rnorm(100, mean = Initial_value$N0[1], sd = 1)
K <- rnorm(100, mean = Initial_value$K[1], sd = 1)
rmax <- rnorm(100, min = 10^-10, max = 10^-2, sd = 1)
t_lag <- rnorm(100, mean = Initial_value$t_lag[1], sd = 1)
######Linear Model######
#quadratic linear model
tryCatch(
q_model <- lm(temp_df$PopBio ~ poly(temp_df$Time, 2, raw = TRUE))
)
#cubic linear model
tryCatch(
c_model <- lm(temp_df$PopBio ~ poly(temp_df$Time, 3, raw = TRUE))
)
#cat("Starting Model Fitting \n")
for (j in 1:100){
####nonlinear model######
tryCatch(
{
l_model <- nlsLM(temp_df$PopBio ~ logistic_model(t = Time, rmax, K ,N0), temp_df,
start = list(rmax = rmax[j],
N0 = N0[j],
K = K[j]),
control = nls.lm.control(maxiter = 100))
log_stats[j,] <- c(aic_function(l_model, temp_df),
bic_function(l_model, temp_df),
coef(l_model)["rmax"],
coef(l_model)["K"],
coef(l_model)["N0"])
},error = function(e){log_stats[j,] <- c(rep(NA,5))},
silent = TRUE)
#store the best replication (the one with the lowest AIC) in a log best dataframe
try(log_best <- subset(log_stats, log_stats$AIC == min(log_stats$AIC, na.rm = TRUE)))
#Gompertz
tryCatch(
{
g_model <- nlsLM(temp_df$LOGPopBio ~ gompertz_model(t = Time, rmax, K, N0, t_lag), temp_df,
start = list(rmax = rmax[j],
K = K[j],
N0 = N0[j],
t_lag = t_lag[j]),
control = nls.lm.control(maxiter = 100))
gomp_stats[j,] <- c(aic_function_forG(g_model, temp_df),
bic_function_forG(g_model, temp_df),
coef(g_model)["rmax"],
coef(g_model)["K"],
coef(g_model)["N0"],
coef(g_model)["t_lag"])
}, error = function(e){gomp_stats[j,] <- c(rep(NA, 6))},
slient = TRUE)
try(gomp_best <- subset(gomp_stats, gomp_stats$AIC == min(gomp_stats$AIC, na.rm = TRUE)))
}
#put everyting in the same pre-allocated dataframe
#Qudratic
try(pre_df$Q_AIC[i] <- aic_function(q_model, temp_df))
try(pre_df$Q_BIC[i] <- bic_function(q_model, temp_df))
try(pre_df$Q_intercept[i] <- coef(q_model)[1])
try(pre_df$Q_slope[i] <- coef(q_model)[2])
#Cubic
try(pre_df$C_AIC[i] <- aic_function(c_model, temp_df))
try(pre_df$C_BIC[i] <- bic_function(c_model, temp_df))
try(pre_df$C_intercept[i] <- coef(c_model)[1])
try(pre_df$C_slope[i] <- coef(c_model)[2])
#use silent = TRUE cause some might not fit
#Logistic
try((pre_df$L_AIC[i] <- log_best$AIC), silent = TRUE)
try((pre_df$L_BIC[i] <- log_best$BIC), silent = TRUE)
try((pre_df$L_K[i] <- log_best$K), silent = TRUE)
try((pre_df$L_Rmax[i] <- log_best$rmax), silent = TRUE)
try((pre_df$L_N0[i] <- log_best$N0), silent = TRUE)
#Gompertz
try((pre_df$G_AIC[i] <- gomp_best$AIC), silent = TRUE)
try((pre_df$G_BIC[i] <- gomp_best$BIC), silent = TRUE)
try((pre_df$G_K[i] <- gomp_best$K), silent = TRUE)
try((pre_df$G_N0[i] <- gomp_best$N0), silent = TRUE)
try((pre_df$G_rmax[i] <- gomp_best$rmax), silent = TRUE)
try((pre_df$G_tlag[i] <- gomp_best$t_lag), silent = TRUE)
}
setwd("Documents/CMEECourseWork/Miniproject/code")
rm(list=ls())
graphics.off()
source("functions.R")
#nlsLM
library("minpack.lm")
cat("Preallocating Dataframes")
data <- read.csv("../data/Wrangled_Data.csv", header = TRUE)
#replace Inf and -Inf to NA
data[is.na(data) | data == "Inf" | data == "-Inf"] <- NA
pre_df <- data.frame(#Unique IDs
ID = c(1:285),
#Quadratic
Q_AIC = rep(0,285),
Q_BIC = rep(0,285),
Q_intercept = rep(0,285),
Q_slope = rep(0,285),
#Cubic
C_AIC = rep(0,285),
C_BIC = rep(0,285),
C_intercept = rep(0,285),
C_slope = rep(0,285),
#Logistic
L_AIC = rep(0,285),
L_BIC = rep(0,285),
L_Rmax = rep(0,285),
L_K = rep(0,285),
L_N0 = rep(0,285),
#Gompertz
G_AIC = rep(0,285),
G_BIC = rep(0,285),
G_rmax = rep(0,285),
G_K = rep(0,285),
G_N0 = rep(0,285),
G_tlag = rep(0,285)
)
#create an initial value
Initial_value <- data.frame(ID = c(1:285),
N0 = rep(0,285),
K = rep(0,285),
rmax = rep(0,285),
t_lag = rep(0,285))
#log the PopBio data
data$LOGPopBio <- log10(data$PopBio)
#same randomization
set.seed(1234)
#create unique subset for each unique IDs
for (i in unique(Initial_value$ID)){
#creates a temporary dataframes for each unique ID
temp_df <- subset(data, data$ID == i)
#each unique IDs
Initial_value[i,1] <- i
#N_start - initial Population
Initial_value[i,2] <- min(temp_df$LOGPopBio)
#K_start- Population
Initial_value[i,3] <- max(temp_df$LOGPopBio)
#Rmax- Gausian distribution.
Initial_value[i,4] <- runif(1, min = 10^-10, max = 10^-2)
#t_lag_start -lag phase last time point
Initial_value[i,5] <- temp_df$Time[which.max(diff(diff(temp_df$LOGPopBio)))]
}
Initial_value[is.na(Initial_value) | Initial_value == "Inf" | Initial_value == "-Inf"] <- NA
#for each unique ID in the data
for (i in unique(data$ID)){
#browser()
#creates a temporary dataframe
temp_df <- data[which(data$ID == i),]
#creates a log stat dataframe to store different tries in each loop
log_stats <- data.frame(AIC = rep(NA, 100),
BIC = rep(NA ,100),
rmax = rep(NA, 100),
K = rep(NA, 100),
N0 = rep(NA, 100))
gomp_stats <- data.frame(AIC = rep(NA, 100),
BIC = rep(NA ,100),
rmax = rep(NA, 100),
K = rep(NA, 100),
N0 = rep(NA, 100),
t_lag = rep(NA, 100))
N0 <- rnorm(100, mean = Initial_value$N0[1])
K <- rnorm(100, mean = Initial_value$K[1])
rmax <- runif(100, min = 10^-10, max = 10^-2)
t_lag <- rnorm(100, mean = Initial_value$t_lag[1])
######Linear Model######
#quadratic linear model
tryCatch(
q_model <- lm(temp_df$PopBio ~ poly(temp_df$Time, 2, raw = TRUE))
)
#cubic linear model
tryCatch(
c_model <- lm(temp_df$PopBio ~ poly(temp_df$Time, 3, raw = TRUE))
)
#cat("Starting Model Fitting \n")
for (j in 1:100){
####nonlinear model######
tryCatch(
{
l_model <- nlsLM(temp_df$PopBio ~ logistic_model(t = Time, rmax, K ,N0), temp_df,
start = list(rmax = rmax[j],
N0 = N0[j],
K = K[j]),
control = nls.lm.control(maxiter = 100))
log_stats[j,] <- c(aic_function(l_model, temp_df),
bic_function(l_model, temp_df),
coef(l_model)["rmax"],
coef(l_model)["K"],
coef(l_model)["N0"])
},error = function(e){log_stats[j,] <- c(rep(NA,5))},
silent = TRUE)
#store the best replication (the one with the lowest AIC) in a log best dataframe
try(log_best <- subset(log_stats, log_stats$AIC == min(log_stats$AIC, na.rm = TRUE)))
#Gompertz
tryCatch(
{
g_model <- nlsLM(temp_df$LOGPopBio ~ gompertz_model(t = Time, rmax, K, N0, t_lag), temp_df,
start = list(rmax = rmax[j],
K = K[j],
N0 = N0[j],
t_lag = t_lag[j]),
control = nls.lm.control(maxiter = 100))
gomp_stats[j,] <- c(aic_function_forG(g_model, temp_df),
bic_function_forG(g_model, temp_df),
coef(g_model)["rmax"],
coef(g_model)["K"],
coef(g_model)["N0"],
coef(g_model)["t_lag"])
}, error = function(e){gomp_stats[j,] <- c(rep(NA, 6))},
slient = TRUE)
try(gomp_best <- subset(gomp_stats, gomp_stats$AIC == min(gomp_stats$AIC, na.rm = TRUE)))
}
#put everyting in the same pre-allocated dataframe
#Qudratic
try(pre_df$Q_AIC[i] <- aic_function(q_model, temp_df))
try(pre_df$Q_BIC[i] <- bic_function(q_model, temp_df))
try(pre_df$Q_intercept[i] <- coef(q_model)[1])
try(pre_df$Q_slope[i] <- coef(q_model)[2])
#Cubic
try(pre_df$C_AIC[i] <- aic_function(c_model, temp_df))
try(pre_df$C_BIC[i] <- bic_function(c_model, temp_df))
try(pre_df$C_intercept[i] <- coef(c_model)[1])
try(pre_df$C_slope[i] <- coef(c_model)[2])
#use silent = TRUE cause some might not fit
#Logistic
try((pre_df$L_AIC[i] <- log_best$AIC), silent = TRUE)
try((pre_df$L_BIC[i] <- log_best$BIC), silent = TRUE)
try((pre_df$L_K[i] <- log_best$K), silent = TRUE)
try((pre_df$L_Rmax[i] <- log_best$rmax), silent = TRUE)
try((pre_df$L_N0[i] <- log_best$N0), silent = TRUE)
#Gompertz
try((pre_df$G_AIC[i] <- gomp_best$AIC), silent = TRUE)
try((pre_df$G_BIC[i] <- gomp_best$BIC), silent = TRUE)
try((pre_df$G_K[i] <- gomp_best$K), silent = TRUE)
try((pre_df$G_N0[i] <- gomp_best$N0), silent = TRUE)
try((pre_df$G_rmax[i] <- gomp_best$rmax), silent = TRUE)
try((pre_df$G_tlag[i] <- gomp_best$t_lag), silent = TRUE)
}
